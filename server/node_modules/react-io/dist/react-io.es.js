import React, { Component, useContext, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import _extends from '@babel/runtime/helpers/extends';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import mapValues from 'lodash/mapValues';
import zipObject from 'lodash/zipObject';
import { of, combineLatest } from 'rxjs';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';

var Context = /*#__PURE__*/React.createContext();
var Consumer = Context.Consumer;
var Provider = Context.Provider;
function IOProvider(_ref) {
  var io = _ref.io,
      children = _ref.children;
  return /*#__PURE__*/React.createElement(Provider, {
    value: io
  }, children);
} // istanbul ignore else

if (process.env.NODE_ENV !== 'production') {
  IOProvider.propTypes = {
    io: PropTypes.func.isRequired,
    children: PropTypes.node
  };
}

var isFunction = function isFunction(o) {
  return typeof o === 'function';
};
var isObservable = function isObservable(o) {
  return o && isFunction(o.subscribe);
};

// Optionally specify io requests to add to prop stream.
// Like recompose/withProps but resolves observables.
// withIO([requests, config])(Component)

var withIO = function withIO(requests, _temp) {
  if (requests === void 0) {
    requests = {};
  }

  var _ref = _temp === void 0 ? {} : _temp,
      StartComponent = _ref.startWith,
      ErrorComponent = _ref.error;

  var isStatic = !isFunction(requests);
  return function (BaseComponent) {
    var WithObservables = /*#__PURE__*/function (_Component) {
      _inheritsLoose(WithObservables, _Component);

      function WithObservables() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Component.call.apply(_Component, [this].concat(args)) || this;

        _defineProperty(_assertThisInitialized(_this), "state", {
          results: null,
          error: null
        });

        _defineProperty(_assertThisInitialized(_this), "handleNext", _this.handleNext.bind(_assertThisInitialized(_this)));

        _defineProperty(_assertThisInitialized(_this), "handleError", _this.handleError.bind(_assertThisInitialized(_this)));

        _defineProperty(_assertThisInitialized(_this), "requestToObservable", _this.requestToObservable.bind(_assertThisInitialized(_this)));

        return _this;
      }

      var _proto = WithObservables.prototype;

      _proto.requestToObservable = function requestToObservable(request) {
        var io = this.context;
        return isObservable(request) ? request : io(request);
      };

      _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {
        this.subscribe(this.props);
      };

      _proto.subscribe = function subscribe(props) {
        var prevSubscription = this.subscription;
        var io = this.context; // Becasue this will be called from componentWillReceiveProps
        // we need to keep a ref to the props we are working with.

        this._props = props;
        this._observables = mapValues(isFunction(requests) ? requests(_extends({}, props, {
          io: io
        })) : requests, this.requestToObservable); // Reset results.

        this.setState({
          results: null
        }); // If given an empty list, combineLatest will never resolve.
        // Emitting an empty object is more useful.

        var observableValues = Object.values(this._observables);
        var combinedObservable = observableValues.length === 0 ? of({}) : combineLatest(observableValues);
        this.subscription = combinedObservable.subscribe({
          next: this.handleNext,
          error: this.handleError
        }); // Important that unsubscribe happens after subscribe.
        // This allows caching of observables.

        if (prevSubscription) {
          prevSubscription.unsubscribe();
        }
      };

      _proto.handleNext = function handleNext(values) {
        this.setState({
          results: zipObject(Object.keys(this._observables), values)
        });
      };

      _proto.handleError = function handleError(error) {
        if (ErrorComponent) {
          this.setState({
            error: error
          });
        } else {
          this.setState(null, function () {
            throw error;
          });
        }
      };

      _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
        if (!isStatic) {
          this.subscribe(nextProps);
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.subscription.unsubscribe();
      };

      _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
        // Only update if we have a start component or results.
        // This forces child components to wait until dynamic requests are done.
        return Boolean(StartComponent || nextState.results);
      };

      _proto.render = function render() {
        var _this$state = this.state,
            results = _this$state.results,
            error = _this$state.error;
        var io = this.context;

        if (error && ErrorComponent) {
          return /*#__PURE__*/React.createElement(ErrorComponent, _extends({}, this.props, {
            io: io,
            error: error
          }));
        }

        if (results) {
          return /*#__PURE__*/React.createElement(BaseComponent, _extends({}, this.props, results, {
            io: io
          }));
        }

        if (!results && StartComponent) {
          return /*#__PURE__*/React.createElement(StartComponent, _extends({}, this.props, {
            io: io
          }));
        }

        return null;
      };

      return WithObservables;
    }(Component); // istanbul ignore else


    _defineProperty(WithObservables, "contextType", Context);

    if (process.env.NODE_ENV !== 'production') {
      WithObservables.displayName = "withIO(" + (BaseComponent.displayName || BaseComponent.name || 'Component') + ")";
    }

    return WithObservables;
  };
};

// API likely to change in future versions of React.
// In a separate module to allow mocking.
// Current suspense API is not testable with enzyme.
var suspend = function suspend(promise) {
  throw promise;
};

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var CacheEntry = /*#__PURE__*/function () {
  function CacheEntry(observable, clean) {
    var _this = this;

    this.hasValue = false;
    this.value = null;
    this.hasError = false;
    this.error = null;
    this.subscribers = 0;
    this.cleaned = false;
    this.observable = observable;
    this.clean = clean;
    this.promise = new Promise(function (resolve) {
      _this.resolve = resolve;
    });
    this.subscription = observable.subscribe({
      next: function next(value) {
        _this.hasValue = true;
        _this.value = value;

        _this.resolve();
      },
      error: function error(_error) {
        _this.hasError = true;
        _this.error = _error;

        _this.resolve();
      }
    });
  }

  var _proto = CacheEntry.prototype;

  _proto.subscribe = function subscribe(observer) {
    var _this2 = this;

    this.subscribers++;
    var subscription = this.observable.subscribe(observer);
    return function () {
      _this2.subscribers--;
      subscription.unsubscribe();

      _this2.checkClean();
    };
  };

  _proto.checkClean = function checkClean() {
    if (!this.cleaned && this.subscribers <= 0) {
      this.subscription.unsubscribe();
      this.clean();
    }
  };

  return CacheEntry;
}(); // It is possible that we end up with cache entries with errors or no subscribers.
// We keep a reference of all caches so we can prune if needed.

/** @type {Set<Map<string, CacheEntry>} */


var caches = new Set();
var pruneCache = function pruneCache() {
  for (var _iterator = _createForOfIteratorHelperLoose(caches), _step; !(_step = _iterator()).done;) {
    var cache = _step.value;

    for (var _iterator2 = _createForOfIteratorHelperLoose(cache), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _step2.value,
          cacheEntry = _step2$value[1];
      cacheEntry.checkClean();
    }
  }
};
/** @return {CacheEntry} */

var getCacheEntry = function getCacheEntry(cacheKey, io, path, params) {
  if (!io._cache) {
    io._cache = new Map();
    caches.add(io._cache);
  }
  /** @type {Map} */


  var cache = io._cache;

  if (!cache.has(cacheKey)) {
    cache.set(cacheKey, new CacheEntry(io(path, params), function () {
      return cache.delete(cacheKey);
    }));
  }

  return cache.get(cacheKey);
};

var useIO = function useIO(path, params) {
  var io = useContext(Context);

  if (path === undefined) {
    return io;
  }

  if (process.env.NODE_ENV !== 'production' && params && typeof params !== 'object') {
    throw new Error('Params must be an object. Are you trying to use a non-OBSERVE method? Only OBSERVE requests can be made using useIO: useIO(path, params)');
  } // Allow rendering immediately by passing a starting value as startWith.
  // We remove this from the params passed to io.


  var startingValue;
  var haveStartingValue = params && Object.prototype.hasOwnProperty.call(params, 'startWith');

  if (haveStartingValue) {
    var _params = params,
        startWith = _params.startWith,
        other = _objectWithoutPropertiesLoose(_params, ["startWith"]);

    startingValue = startWith;
    params = other;
  }

  var cacheKey = path + (params ? JSON.stringify(params) : '');
  var cacheEntry = getCacheEntry(cacheKey, io, path, params);

  if (cacheEntry.hasError) {
    throw cacheEntry.error;
  }

  if (!cacheEntry.hasValue && !haveStartingValue) {
    return suspend(cacheEntry.promise);
  }

  if (cacheEntry.hasValue) {
    startingValue = cacheEntry.value;
  }

  var _useState = useState(startingValue),
      state = _useState[0],
      setState = _useState[1];

  useEffect(function () {
    // Reset state, noop if identical.
    setState(startingValue);
    return cacheEntry.subscribe({
      next: setState,
      // Changing state will trigger rerender and the error will be thrown
      // from the cacheEntry object.
      // This relies on errors being different to values...
      error: setState
    });
  }, [cacheKey]);
  return state;
};

var withObservables = withIO;

export { Context as IOContext, IOProvider, pruneCache, useIO, withIO, withObservables };
