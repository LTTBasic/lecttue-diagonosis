import React, { Component, useContext, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import _extends from '@babel/runtime/helpers/extends';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import mapValues from 'lodash/mapValues';
import zipObject from 'lodash/zipObject';
import { of, combineLatest } from 'rxjs';

const Context = /*#__PURE__*/React.createContext();
const Consumer = Context.Consumer;
const Provider = Context.Provider;
function IOProvider({
  io,
  children
}) {
  return /*#__PURE__*/React.createElement(Provider, {
    value: io
  }, children);
} // istanbul ignore else

if (process.env.NODE_ENV !== 'production') {
  IOProvider.propTypes = {
    io: PropTypes.func.isRequired,
    children: PropTypes.node
  };
}

const isFunction = o => typeof o === 'function';
const isObservable = o => o && isFunction(o.subscribe);

// Optionally specify io requests to add to prop stream.
// Like recompose/withProps but resolves observables.
// withIO([requests, config])(Component)

const withIO = (requests = {}, {
  startWith: StartComponent,
  error: ErrorComponent
} = {}) => {
  const isStatic = !isFunction(requests);
  return BaseComponent => {
    class WithObservables extends Component {
      constructor(...args) {
        super(...args);

        _defineProperty(this, "state", {
          results: null,
          error: null
        });

        _defineProperty(this, "handleNext", this.handleNext.bind(this));

        _defineProperty(this, "handleError", this.handleError.bind(this));

        _defineProperty(this, "requestToObservable", this.requestToObservable.bind(this));
      }

      requestToObservable(request) {
        const io = this.context;
        return isObservable(request) ? request : io(request);
      }

      UNSAFE_componentWillMount() {
        this.subscribe(this.props);
      }

      subscribe(props) {
        const prevSubscription = this.subscription;
        const io = this.context; // Becasue this will be called from componentWillReceiveProps
        // we need to keep a ref to the props we are working with.

        this._props = props;
        this._observables = mapValues(isFunction(requests) ? requests({ ...props,
          io
        }) : requests, this.requestToObservable); // Reset results.

        this.setState({
          results: null
        }); // If given an empty list, combineLatest will never resolve.
        // Emitting an empty object is more useful.

        const observableValues = Object.values(this._observables);
        const combinedObservable = observableValues.length === 0 ? of({}) : combineLatest(observableValues);
        this.subscription = combinedObservable.subscribe({
          next: this.handleNext,
          error: this.handleError
        }); // Important that unsubscribe happens after subscribe.
        // This allows caching of observables.

        if (prevSubscription) {
          prevSubscription.unsubscribe();
        }
      }

      handleNext(values) {
        this.setState({
          results: zipObject(Object.keys(this._observables), values)
        });
      }

      handleError(error) {
        if (ErrorComponent) {
          this.setState({
            error
          });
        } else {
          this.setState(null, () => {
            throw error;
          });
        }
      }

      UNSAFE_componentWillReceiveProps(nextProps) {
        if (!isStatic) {
          this.subscribe(nextProps);
        }
      }

      componentWillUnmount() {
        this.subscription.unsubscribe();
      }

      shouldComponentUpdate(nextProps, nextState) {
        // Only update if we have a start component or results.
        // This forces child components to wait until dynamic requests are done.
        return Boolean(StartComponent || nextState.results);
      }

      render() {
        const {
          results,
          error
        } = this.state;
        const io = this.context;

        if (error && ErrorComponent) {
          return /*#__PURE__*/React.createElement(ErrorComponent, _extends({}, this.props, {
            io: io,
            error: error
          }));
        }

        if (results) {
          return /*#__PURE__*/React.createElement(BaseComponent, _extends({}, this.props, results, {
            io: io
          }));
        }

        if (!results && StartComponent) {
          return /*#__PURE__*/React.createElement(StartComponent, _extends({}, this.props, {
            io: io
          }));
        }

        return null;
      }

    } // istanbul ignore else


    _defineProperty(WithObservables, "contextType", Context);

    if (process.env.NODE_ENV !== 'production') {
      WithObservables.displayName = `withIO(${BaseComponent.displayName || BaseComponent.name || 'Component'})`;
    }

    return WithObservables;
  };
};

// API likely to change in future versions of React.
// In a separate module to allow mocking.
// Current suspense API is not testable with enzyme.
const suspend = promise => {
  throw promise;
};

class CacheEntry {
  constructor(observable, clean) {
    this.hasValue = false;
    this.value = null;
    this.hasError = false;
    this.error = null;
    this.subscribers = 0;
    this.cleaned = false;
    this.observable = observable;
    this.clean = clean;
    this.promise = new Promise(resolve => {
      this.resolve = resolve;
    });
    this.subscription = observable.subscribe({
      next: value => {
        this.hasValue = true;
        this.value = value;
        this.resolve();
      },
      error: error => {
        this.hasError = true;
        this.error = error;
        this.resolve();
      }
    });
  }

  subscribe(observer) {
    this.subscribers++;
    const subscription = this.observable.subscribe(observer);
    return () => {
      this.subscribers--;
      subscription.unsubscribe();
      this.checkClean();
    };
  }

  checkClean() {
    if (!this.cleaned && this.subscribers <= 0) {
      this.subscription.unsubscribe();
      this.clean();
    }
  }

} // It is possible that we end up with cache entries with errors or no subscribers.
// We keep a reference of all caches so we can prune if needed.

/** @type {Set<Map<string, CacheEntry>} */


const caches = new Set();
const pruneCache = () => {
  for (const cache of caches) {
    for (const [, cacheEntry] of cache) {
      cacheEntry.checkClean();
    }
  }
};
/** @return {CacheEntry} */

const getCacheEntry = (cacheKey, io, path, params) => {
  if (!io._cache) {
    io._cache = new Map();
    caches.add(io._cache);
  }
  /** @type {Map} */


  const cache = io._cache;

  if (!cache.has(cacheKey)) {
    cache.set(cacheKey, new CacheEntry(io(path, params), () => cache.delete(cacheKey)));
  }

  return cache.get(cacheKey);
};

const useIO = (path, params) => {
  const io = useContext(Context);

  if (path === undefined) {
    return io;
  }

  if (process.env.NODE_ENV !== 'production' && params && typeof params !== 'object') {
    throw new Error('Params must be an object. Are you trying to use a non-OBSERVE method? Only OBSERVE requests can be made using useIO: useIO(path, params)');
  } // Allow rendering immediately by passing a starting value as startWith.
  // We remove this from the params passed to io.


  let startingValue;
  const haveStartingValue = params && Object.prototype.hasOwnProperty.call(params, 'startWith');

  if (haveStartingValue) {
    const {
      startWith,
      ...other
    } = params;
    startingValue = startWith;
    params = other;
  }

  const cacheKey = path + (params ? JSON.stringify(params) : '');
  const cacheEntry = getCacheEntry(cacheKey, io, path, params);

  if (cacheEntry.hasError) {
    throw cacheEntry.error;
  }

  if (!cacheEntry.hasValue && !haveStartingValue) {
    return suspend(cacheEntry.promise);
  }

  if (cacheEntry.hasValue) {
    startingValue = cacheEntry.value;
  }

  const [state, setState] = useState(startingValue);
  useEffect(() => {
    // Reset state, noop if identical.
    setState(startingValue);
    return cacheEntry.subscribe({
      next: setState,
      // Changing state will trigger rerender and the error will be thrown
      // from the cacheEntry object.
      // This relies on errors being different to values...
      error: setState
    });
  }, [cacheKey]);
  return state;
};

const withObservables = withIO;

export { Context as IOContext, IOProvider, pruneCache, useIO, withIO, withObservables };
